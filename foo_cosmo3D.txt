[1mdiff --git a/theory/cosmo3D.c b/theory/cosmo3D.c[m
[1mold mode 100644[m
[1mnew mode 100755[m
[1mindex 6449a90..9835887[m
[1m--- a/theory/cosmo3D.c[m
[1m+++ b/theory/cosmo3D.c[m
[36m@@ -2,7 +2,7 @@[m
 #include <stdlib.h>[m
 #include <stdio.h>[m
 #include <assert.h>[m
[31m-#include "../class/include/class.h"[m
[32m+[m[32m#include "../class_v3.0.1/include/class.h"[m
 [m
 #include <gsl/gsl_odeiv.h>[m
 #include <gsl/gsl_integration.h>[m
[36m@@ -35,6 +35,7 @@[m
 double omv_vareos(double a);[m
 static inline double hoverh0(double a);[m
 double growfac(double a);[m
[32m+[m[32mdouble growfac_cluster(double a);[m
 //int func_for_growfac(double a,const double y[],double f[],void *params);[m
 double Tsqr_EH_wiggle(double khoverMPC);[m
 //double int_for_sigma_r_sqr(double k, void * args);[m
[36m@@ -187,6 +188,10 @@[m [mdouble growfac(double a)[m
 [m
 [m
 [m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
 // ---------------------------- Transfer Function from EH98 ----------------------[m
 //Input: k -- Wavenumber at which to calculate transfer function, in Mpc^-1. Output: Returns the value of the full transfer function fitting formula. This is the form given in Section 3 of Eisenstein & Hu (1997). Notes: Units are Mpc, not h^-1 Mpc.[m
 [m
[36m@@ -391,65 +396,71 @@[m [mdouble Delta_L_wiggle(double k)[m
 // }[m
 void free_class_structs([m
  struct background *ba,[m
[31m- struct thermo *th,[m
[31m- struct perturbs *pt,[m
[31m- struct transfers *tr,[m
[32m+[m[32m struct thermodynamics *th,[m
[32m+[m[32m struct perturbations *pt,[m
[32m+[m[32m struct transfer *tr,[m
  struct primordial *pm,[m
[31m- struct spectra *sp,[m
[31m- struct nonlinear *nl,[m
[31m- struct lensing *le){[m
[32m+[m[32m struct harmonic *hr,[m
[32m+[m[32m struct fourier *fo,[m
[32m+[m[32m struct lensing *le,[m
[32m+[m[32m struct distortions *sd){[m
   if (lensing_free(le) == _FAILURE_) {[m
     printf("\n\nError in lensing_free \n=>%s\n",le->error_message);[m
   }[m
 [m
[31m-  if (spectra_free(sp) == _FAILURE_) {[m
[31m-    printf("\n\nError in spectra_free \n=>%s\n",sp->error_message);[m
[32m+[m
[32m+[m[32m  if (harmonic_free(hr) == _FAILURE_) {[m
[32m+[m[32m    printf("\n\nError in harmonic_free \n=>%s\n",hr->error_message);[m
   }[m
 [m
   if (transfer_free(tr) == _FAILURE_) {[m
     printf("\n\nError in transfer_free \n=>%s\n",tr->error_message);[m
   }[m
 [m
[31m-  if (nonlinear_free(nl) == _FAILURE_) {[m
[31m-    printf("\n\nError in nonlinear_free \n=>%s\n",nl->error_message);[m
[32m+[m[32m  if (fourier_free(fo) == _FAILURE_) {[m
[32m+[m[32m    printf("\n\nError in fourier_free \n=>%s\n",fo->error_message);[m
   }[m
 [m
   if (primordial_free(pm) == _FAILURE_) {[m
     printf("\n\nError in primordial_free \n=>%s\n",pm->error_message);[m
   }[m
 [m
[31m-  if (perturb_free(pt) == _FAILURE_) {[m
[31m-    printf("\n\nError in perturb_free \n=>%s\n",pt->error_message);[m
[32m+[m[32m  if (perturbations_free(pt) == _FAILURE_) {[m
[32m+[m[32m    printf("\n\nError in perturbations_free \n=>%s\n",pt->error_message);[m
   }[m
 [m
   if (thermodynamics_free(th) == _FAILURE_) {[m
     printf("\n\nError in thermodynamics_free \n=>%s\n",th->error_message);[m
   }[m
[31m-[m
   if (background_free(ba) == _FAILURE_) {[m
     printf("\n\nError in background_free \n=>%s\n",ba->error_message);[m
   }[m
[32m+[m[32m  if (distortions_free(sd) == _FAILURE_) {[m
[32m+[m[32m    printf("\n\nError in distortions_free \n=>%s\n",sd->error_message);[m
[32m+[m[32m  }[m
 }[m
 [m
 int run_class([m
   struct file_content *fc,[m
   struct background *ba,[m
[31m-  struct thermo *th,[m
[31m-  struct perturbs *pt,[m
[31m-  struct transfers *tr,[m
[32m+[m[32m  struct thermodynamics *th,[m
[32m+[m[32m  struct perturbations *pt,[m
[32m+[m[32m  struct transfer *tr,[m
   struct primordial *pm,[m
[31m-  struct spectra *sp,[m
[31m-  struct nonlinear *nl,[m
[31m-  struct lensing *le){[m
[32m+[m[32m  struct harmonic *hr,[m
[32m+[m[32m  struct fourier *fo,[m
[32m+[m[32m  struct lensing *le,[m
[32m+[m[32m  struct distortions *sd){[m
   struct precision pr;        // for precision parameters[m
   struct output op;           /* for output files */[m
   ErrorMsg errmsg; // for error messages[m
 [m
[31m-  if(input_init(fc,&pr,ba,th,pt,tr,pm,sp,nl,le,&op,errmsg) == _FAILURE_) {[m
[32m+[m[32m  if(input_read_from_file(fc,&pr,ba,th,pt,tr,pm,hr,fo,le,sd,&op,errmsg) == _FAILURE_) {[m
     fprintf(stderr,"cosmo3D.c: Error running CLASS input:%s\n",errmsg);[m
     parser_free(fc);[m
     return 1;[m
   }[m
[32m+[m
   if (background_init(&pr,ba) == _FAILURE_) {[m
     fprintf(stderr,"cosmo3D.c: Error running CLASS background:%s\n",ba->error_message);[m
     return 1;[m
[36m@@ -461,46 +472,55 @@[m [mint run_class([m
   }[m
   cosmology.theta_s = 100.*th->rs_rec/th->ra_rec;[m
   cosmology.h0 = ba->h;[m
[31m-//    printf("theta_* = %.5f\n",cosmology.theta_s);[m
[31m-//    printf("h_CLASS = %.3f\n\n", ba->h);[m
[31m-  if (perturb_init(&pr,ba,th,pt) == _FAILURE_) {[m
[31m-    fprintf(stderr,"cosmo3D.c: Error running CLASS perturb:%s\n",pt->error_message);[m
[32m+[m[32m    //printf("theta_* = %.5f\n",cosmology.theta_s);[m
[32m+[m[32m    //printf("h_CLASS = %.3f\n\n", ba->h);[m
[32m+[m[32m  if (perturbations_init(&pr,ba,th,pt) == _FAILURE_) {[m
[32m+[m[32m    fprintf(stderr,"cosmo3D.c: Error running CLASS perturbations:%s\n",pt->error_message);[m
     thermodynamics_free(th);[m
     background_free(ba);[m
     return 1;[m
   }[m
   if (primordial_init(&pr,pt,pm) == _FAILURE_) {[m
     fprintf(stderr,"cosmo3D.c: Error running CLASS primordial:%s\n",pm->error_message);[m
[31m-    perturb_free(pt);[m
[32m+[m[32m    perturbations_free(pt);[m
     thermodynamics_free(th);[m
     background_free(ba);[m
     return 1;[m
   }[m
 [m
[31m-  if (nonlinear_init(&pr,ba,th,pt,pm,nl) == _FAILURE_) {[m
[31m-    fprintf(stderr,"cosmo3D.c: Error running CLASS nonlinear:%s\n",nl->error_message);[m
[32m+[m[32m  if (fourier_init(&pr,ba,th,pt,pm,fo) == _FAILURE_) {[m
[32m+[m[32m    fprintf(stderr,"cosmo3D.c: Error running CLASS fourier:%s\n",fo->error_message);[m
     primordial_free(pm);[m
[31m-    perturb_free(pt);[m
[32m+[m[32m    perturbations_free(pt);[m
     thermodynamics_free(th);[m
     background_free(ba);[m
     return 1;[m
   }[m
 [m
[31m-  if (transfer_init(&pr,ba,th,pt,nl,tr) == _FAILURE_) {[m
[32m+[m[32m  if (distortions_init(&pr,ba,th,pt,pm,sd) == _FAILURE_) {[m
[32m+[m[32m    fprintf(stderr,"cosmo3D.c: Error running CLASS distortions:%s\n",sd->error_message);[m
[32m+[m[32m    primordial_free(pm);[m
[32m+[m[32m    perturbations_free(pt);[m
[32m+[m[32m    thermodynamics_free(th);[m
[32m+[m[32m    background_free(ba);[m
[32m+[m[32m    return 1;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  if (transfer_init(&pr,ba,th,pt,fo,tr) == _FAILURE_) {[m
     fprintf(stderr,"cosmo3D.c: Error running CLASS transfer:%s\n",tr->error_message);[m
[31m-    nonlinear_free(nl);[m
[32m+[m[32m    fourier_free(fo);[m
     primordial_free(pm);[m
[31m-    perturb_free(pt);[m
[32m+[m[32m    perturbations_free(pt);[m
     thermodynamics_free(th);[m
     background_free(ba);[m
     return 1;[m
   }[m
[31m-  if (spectra_init(&pr,ba,pt,pm,nl,tr,sp) == _FAILURE_) {[m
[31m-    fprintf(stderr,"cosmo3D.c: Error running CLASS spectra:%s\n",sp->error_message);[m
[32m+[m[32m  if (harmonic_init(&pr,ba,pt,pm,fo,tr,hr) == _FAILURE_) {[m
[32m+[m[32m    fprintf(stderr,"cosmo3D.c: Error running CLASS harmonic:%s\n",hr->error_message);[m
     transfer_free(tr);[m
[31m-    nonlinear_free(nl);[m
[32m+[m[32m    fourier_free(fo);[m
     primordial_free(pm);[m
[31m-    perturb_free(pt);[m
[32m+[m[32m    perturbations_free(pt);[m
     thermodynamics_free(th);[m
     background_free(ba);[m
     return 1;[m
[36m@@ -510,13 +530,14 @@[m [mint run_class([m
 double get_class_s8(struct file_content *fc, int *status){[m
 //structures for class test run[m
     struct background ba;       // for cosmological background[m
[31m-    struct thermo th;           // for thermodynamics[m
[31m-    struct perturbs pt;         // for source functions[m
[31m-    struct transfers tr;        // for transfer functions[m
[32m+[m[32m    struct thermodynamics th;           // for thermodynamics[m
[32m+[m[32m    struct perturbations pt;         // for source functions[m
[32m+[m[32m    struct transfer tr;        // for transfer functions[m
     struct primordial pm;       // for primordial spectra[m
[31m-    struct spectra sp;          // for output spectra[m
[31m-    struct nonlinear nl;        // for non-linear spectra[m
[32m+[m[32m    struct harmonic hr;          // for output spectra[m
[32m+[m[32m    struct fourier fo;        // for non-linear spectra[m
     struct lensing le;[m
[32m+[m[32m    struct distortions sd;[m
 [m
   //temporarily overwrite P_k_max_1/Mpc to speed up sigma_8 calculation[m
     double k_max_old = 0.;[m
[36m@@ -528,24 +549,27 @@[m [mdouble get_class_s8(struct file_content *fc, int *status){[m
       k_max_old = strtof(fc->value[position_kmax],NULL);[m
       sprintf(fc->value[position_kmax],"%e",10.);[m
     }[m
[31m-    *status = run_class(fc,&ba,&th,&pt,&tr,&pm,&sp,&nl,&le);[m
[31m-    if (*status ==0) free_class_structs(&ba,&th,&pt,&tr,&pm,&sp,&nl,&le);[m
[32m+[m[32m    *status = run_class(fc,&ba,&th,&pt,&tr,&pm,&hr,&fo,&le,&sd);[m
[32m+[m[32m    double sigma8 = *fo.sigma8;[m
[32m+[m[32m    if (*status ==0) free_class_structs(&ba,&th,&pt,&tr,&pm,&hr,&fo,&le,&sd);[m
     if (k_max_old >0){[m
       sprintf(fc->value[position_kmax],"%e",k_max_old);[m
     }[m
[31m-    return sp.sigma8;[m
[32m+[m[32m    //if (strcmp(__VERSION__, "v2.9.2")>=0) return  *fo.sigma8;[m
[32m+[m[32m    return sigma8;[m
   }[m
 [m
   double get_class_As(struct file_content *fc, int position_As,double sigma8, int *status){[m
 //structures for class test run[m
     struct background ba;       // for cosmological background[m
[31m-    struct thermo th;           // for thermodynamics[m
[31m-    struct perturbs pt;         // for source functions[m
[31m-    struct transfers tr;        // for transfer functions[m
[32m+[m[32m    struct thermodynamics th;           // for thermodynamics[m
[32m+[m[32m    struct perturbations pt;         // for source functions[m
[32m+[m[32m    struct transfer tr;        // for transfer functions[m
     struct primordial pm;       // for primordial spectra[m
[31m-    struct spectra sp;          // for output spectra[m
[31m-    struct nonlinear nl;        // for non-linear spectra[m
[32m+[m[32m    struct harmonic hr;          // for output spectra[m
[32m+[m[32m    struct fourier fo;        // for non-linear spectra[m
     struct lensing le;[m
[32m+[m[32m    struct distortions sd;[m
 [m
   //temporarily overwrite P_k_max_1/Mpc to speed up sigma_8 calculation[m
     double k_max_old = 0.;[m
[36m@@ -560,15 +584,25 @@[m [mdouble get_class_s8(struct file_content *fc, int *status){[m
     A_s_guess = 2.43e-9*pow(sigma8/0.87659,2.0);[m
     printf("A_s_guess=%e\n",A_s_guess);[m
     sprintf(fc->value[position_As],"%e",A_s_guess);[m
[31m-[m
[31m-    *status = run_class(fc,&ba,&th,&pt,&tr,&pm,&sp,&nl,&le);[m
[31m-    A_s_guess*=pow(sigma8/sp.sigma8,2.);[m
[32m+[m[32m/*[m
[32m+[m[32m    *status = run_class(fc,&ba,&th,&pt,&tr,&pm,&hr,&fo,&le,&sd);[m
[32m+[m[32m    A_s_guess*=pow(sigma8/ *fo.sigma8,2.);[m
     printf("A_s_guess=%e\n",A_s_guess);[m
     sprintf(fc->value[position_As],"%e",A_s_guess);[m
[31m-    *status = run_class(fc,&ba,&th,&pt,&tr,&pm,&sp,&nl,&le);[m
[31m-    A_s_guess*=pow(sigma8/sp.sigma8,2.);[m
[32m+[m[32m    *status = run_class(fc,&ba,&th,&pt,&tr,&pm,&hr,&fo,&le,&sd);[m
[32m+[m[32m    A_s_guess*=pow(sigma8/ *fo.sigma8,2.);[m
     printf("A_s_guess=%e\n",A_s_guess);[m
[31m-    if (*status ==0) free_class_structs(&ba,&th,&pt,&tr,&pm,&sp,&nl,&le);[m
[32m+[m[32m    sprintf(fc->value[position_As],"%e",A_s_guess);*/[m
[32m+[m
[32m+[m[32m    int tindex = 0;[m
[32m+[m[32m    for (tindex=0; tindex<12; tindex++){[m[41m     [m
[32m+[m[32m    *status = run_class(fc,&ba,&th,&pt,&tr,&pm,&hr,&fo,&le,&sd);[m
[32m+[m[32m    A_s_guess*=pow(sigma8/ *fo.sigma8,2.);[m
[32m+[m[32m    printf("A_s_guess=%e, %e %e\n",A_s_guess,*fo.sigma8, pm.A_s);[m
[32m+[m[32m    sprintf(fc->value[position_As],"%e",A_s_guess);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (*status ==0) free_class_structs(&ba,&th,&pt,&tr,&pm,&hr,&fo,&le,&sd);[m
 [m
     if (k_max_old >0){[m
       sprintf(fc->value[position_kmax],"%e",k_max_old);[m
[36m@@ -605,8 +639,10 @@[m [mdouble get_class_s8(struct file_content *fc, int *status){[m
     strcpy(fc->name[6],"h");[m
     sprintf(fc->value[6],"%e",cosmology.h0);[m
   }[m
[31m-  strcpy(fc->name[7],"Omega_cdm");[m
[31m-  sprintf(fc->value[7],"%e",cosmology.Omega_m-cosmology.Omega_nu-cosmology.omb);[m
[32m+[m[32m  //strcpy(fc->name[7],"Omega_cdm");[m
[32m+[m[32m  //sprintf(fc->value[7],"%e",cosmology.Omega_m-cosmology.Omega_nu-cosmology.omb);[m
[32m+[m
[32m+[m
 [m
   strcpy(fc->name[8],"Omega_b");[m
   sprintf(fc->value[8],"%e",cosmology.omb);[m
[36m@@ -628,43 +664,251 @@[m [mdouble get_class_s8(struct file_content *fc, int *status){[m
     sprintf(fc->value[13],"%e",cosmology.wa);[m
   }[m
 // pass neutrino parameters[m
[31m-  if (cosmology.M_nu > 1.e-5 || cosmology.Omega_nu >0.){[m
[31m-    strcpy(fc->name[14],"N_ncdm");[m
[31m-    sprintf(fc->value[14],"%d",1);[m
 [m
[31m-    if (cosmology.Omega_nu >0.)[m
[31m-    {[m
[31m-      strcpy(fc->name[15],"Omega_ncdm");[m
[31m-//      sprintf(fc->value[15],"%e,%e,%e",cosmology.Omega_nu/3,cosmology.Omega_nu/3,cosmology.Omega_nu/3);[m
[31m-      sprintf(fc->value[15],"%e",cosmology.Omega_nu);[m
[31m-    }[m
[31m-    else{[m
[31m-      strcpy(fc->name[15],"m_ncdm"); //\Sigma(m_nu) in eV[m
[31m-      sprintf(fc->value[15],"%e,%e,%e",cosmology.M_nu/3,cosmology.M_nu/3,cosmology.M_nu/3);[m
[31m-      sprintf(fc->value[15],"%e,%e,%e",cosmology.M_nu/3,cosmology.M_nu/3,cosmology.M_nu/3);[m
[32m+[m[32m      //user could TEHCNICALLY pass N_ur or Omega_ur, but I think requiring only N_ur is OK[m
[32m+[m
[32m+[m[32m      //N_ur (N_eff) is affected by N_ncdm. These logic statements enforce N_ur based on common values of N_ncdm,[m
[32m+[m[32m      // as N_ur should equal 3.0440 in the early universe[m
[32m+[m[32m      double Neff_standard;[m
[32m+[m[32m      Neff_standard = 3.0440;[m
[32m+[m[32m      double Tncdm_standard;[m
[32m+[m[32m      Tncdm_standard = 0.71611;[m
[32m+[m[41m      [m
[32m+[m
[32m+[m[32m      //TODO implement different hierarchies[m
[32m+[m[32m      if (cosmology.M_nu>0. || cosmology.Omega_nu>0.){[m[41m [m
[32m+[m[32m              strcpy(fc->name[16],"N_ur");[m
[32m+[m[32m      sprintf(fc->value[16],"%e",cosmology.N_eff);[m
[32m+[m[41m        [m
[32m+[m[32m        double ncdm_mass_or_omega;[m
[32m+[m[32m        if (cosmology.M_nu>0.){ ncdm_mass_or_omega = cosmology.M_nu; strcpy(fc->name[15],"m_ncdm");}[m
[32m+[m[32m        else {ncdm_mass_or_omega = cosmology.Omega_nu; strcpy(fc->name[15],"Omega_ncdm");}[m
[32m+[m[41m        [m
[32m+[m[32m        //treatment of sterile neutrinos[m
[32m+[m[32m        //when varying sterile neutrino mass, we are interested in the active neutrino minimal mass model[m
[32m+[m[32m        //i.e. 2 massless and 1 massive active neutrinos at 0.06eV[m
[32m+[m[32m        //N_ncdm would be redefined to be 2, as there is an active and sterile massive ncdm component[m
[32m+[m[32m        if (cosmology.meff>0){[m
[32m+[m[32m          double sterile_part;[m
[32m+[m[32m          if (cosmology.M_nu>0) {[m
[32m+[m[32m            sterile_part = cosmology.meff;[m
[32m+[m[32m            sprintf(fc->value[15],"%e,%e",ncdm_mass_or_omega, sterile_part);[m
[32m+[m[32m          }[m
[32m+[m[32m          else {[m
[32m+[m[32m            sterile_part = cosmology.meff/94.1/cosmology.h0/cosmology.h0;[m
[32m+[m[32m            sprintf(fc->value[15],"%e,%e",ncdm_mass_or_omega-sterile_part, sterile_part);[m
[32m+[m[32m          }[m
[32m+[m[32m          cosmology.N_ncdm = 2;[m
[32m+[m[32m          strcpy(fc->name[14],"N_ncdm");[m
[32m+[m[32m          sprintf(fc->value[14],"%d",cosmology.N_ncdm);[m
[32m+[m[41m          [m
[32m+[m[32m            //printf("The two components are  %f %f \n", ncdm_mass_or_omega, sterile_part);[m
[32m+[m
[32m+[m[32m          /*strcpy(fc->name[24],"fourier_verbose");[m
[32m+[m[32m          sprintf(fc->value[24],"%d",5);[m
[32m+[m[32m          strcpy(fc->name[26],"background_verbose");[m
[32m+[m[32m          sprintf(fc->value[26],"%d",5);[m
[32m+[m[32m          strcpy(fc->name[25],"thermodynamics_verbose");[m
[32m+[m[32m          sprintf(fc->value[25],"%d",5);*/[m
[32m+[m
[32m+[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m        else {[m
[32m+[m[32m          //printf("N_UR is %f\n", cosmology.N_ur);[m
[32m+[m[32m          //strcpy(fc->name[17],"T_ncdm");[m
[32m+[m[32m          //sprintf(fc->value[17],"%e", Tncdm_standard); //default CLASS value to have nuetrino normalization to be 93.14eV[m
[32m+[m[32m          switch(cosmology.N_ncdm){//This switch case also handles Neff>=Neff_standard[m
[32m+[m[32m          case 0:[m
[32m+[m
[32m+[m[32m            sprintf(fc->value[15],"%e",ncdm_mass_or_omega);[m
[32m+[m[32m            /*strcpy(fc->name[24],"fourier_verbose");[m
[32m+[m[32m            sprintf(fc->value[24],"%d",5);[m
[32m+[m[32m            strcpy(fc->name[26],"background_verbose");[m
[32m+[m[32m            sprintf(fc->value[26],"%d",5);[m
[32m+[m[32m            strcpy(fc->name[25],"thermodynamics_verbose");[m
[32m+[m[32m            sprintf(fc->value[25],"%d",5);*/[m
[32m+[m[32m            break;[m
[32m+[m[32m          case 1:[m[41m [m
[32m+[m[32m            strcpy(fc->name[14],"N_ncdm");[m
[32m+[m[32m            sprintf(fc->value[14],"%d",cosmology.N_ncdm);[m
[32m+[m[32m            //raise error here if N_ur is defined and not equal to value below[m
[32m+[m[32m            //this means that Neff != Neff_standard in early universe, must protect![m
[32m+[m[32m            sprintf(fc->value[16],"%e",2.0308 + (cosmology.N_eff - Neff_standard));[m
[32m+[m[32m            //cosmology.N_ur = 2.0328;[m
[32m+[m[32m            sprintf(fc->value[15],"%e",ncdm_mass_or_omega);[m
[32m+[m[32m            //strcpy(fc->name[24],"fourier_verbose");[m
[32m+[m[32m            //sprintf(fc->value[24],"%d",5);[m
[32m+[m[32m            //strcpy(fc->name[26],"background_verbose");[m
[32m+[m[32m            //sprintf(fc->value[26],"%d",5);[m
[32m+[m[32m            //strcpy(fc->name[25],"thermodynamics_verbose");[m
[32m+[m[32m            //sprintf(fc->value[25],"%d",5);[m
[32m+[m[32m            //strcpy(fc->name[27],"perturbations_verbose");[m
[32m+[m[32m            //sprintf(fc->value[27],"%d",5);[m
[32m+[m[32m            break;[m
[32m+[m[32m          case 2:[m
[32m+[m[32m            strcpy(fc->name[14],"N_ncdm");[m
[32m+[m[32m            sprintf(fc->value[14],"%d",cosmology.N_ncdm);[m
[32m+[m[32m            //raise error here if N_ur is defined and not equal to value below[m
[32m+[m[32m            //this means that Neff != Neff_standard in early universe, must protect![m
[32m+[m[32m            //sprintf(fc->value[16],"%e",1.0196);[m
[32m+[m[32m            sprintf(fc->value[16],"%e",1.0176 + (cosmology.N_eff - Neff_standard));[m
[32m+[m[32m            //cosmology.N_ur = 1.0196;[m
[32m+[m[32m            sprintf(fc->value[15],"%e,%e",ncdm_mass_or_omega/2, ncdm_mass_or_omega/2);[m
[32m+[m[32m            //sprintf(fc->value[17],"%e,%e", Tncdm_standard, Tncdm_standard);[m
[32m+[m[32m            if(cosmology.meff>0 && cosmology.M_nu>0) sprintf(fc->value[15],"%e,%e",ncdm_mass_or_omega, cosmology.meff);[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m            break;[m
[32m+[m[32m          case 3:[m
[32m+[m[32m            strcpy(fc->name[14],"N_ncdm");[m
[32m+[m[32m            sprintf(fc->value[14],"%d",cosmology.N_ncdm);[m
[32m+[m[32m            //printf("N_UR is %f\n", cosmology.N_ur);[m
[32m+[m[32m            //raise error here if N_ur is defined and not equal to value below[m
[32m+[m[32m            //this means that Neff != Neff_standard in early universe, must protect![m
[32m+[m[32m            //sprintf(fc->value[16],"%e",0.00641);[m
[32m+[m[32m            sprintf(fc->value[16],"%e",0.00441 + (cosmology.N_eff - Neff_standard));[m
[32m+[m[32m            //cosmology.N_ur = 0.00641;[m
[32m+[m[32m            //cosmology.N_ur = 0.0328;[m
[32m+[m[32m            //sprintf(fc->value[16],"%e",0.0328);[m[41m [m
[32m+[m[32m            sprintf(fc->value[15],"%e,%e,%e",ncdm_mass_or_omega/3,ncdm_mass_or_omega/3,ncdm_mass_or_omega/3);[m
[32m+[m[32m            //sprintf(fc->value[17],"%e,%e,%e", Tncdm_standard, Tncdm_standard, Tncdm_standard);[m
[32m+[m[32m            //strcpy(fc->name[27],"ncdm_psd_parameters");[m
[32m+[m[32m            //sprintf(fc->value[27],"%e,%e,%e",0.3 ,0.5, 0.05);[m
[32m+[m[32m            //strcpy(fc->name[28],"use_ncdm_psd_files");[m
[32m+[m[32m            //sprintf(fc->value[28],"%d,%d,%d",0,0,0);[m
[32m+[m[32m            //strcpy(fc->name[24],"fourier_verbose");[m
[32m+[m[32m            //sprintf(fc->value[24],"%d",5);[m
[32m+[m[32m            //strcpy(fc->name[26],"background_verbose");[m
[32m+[m[32m            //sprintf(fc->value[26],"%d",5);[m
[32m+[m[32m            //strcpy(fc->name[25],"thermodynamics_verbose");[m
[32m+[m[32m            //sprintf(fc->value[25],"%d",5);[m
[32m+[m[32m            //strcpy(fc->name[17],"N_idr");[m
[32m+[m[32m            //sprintf(fc->value[17],"%e",1.0);[m
[32m+[m[32m            break;[m
[32m+[m[32m          case 4:[m
[32m+[m[32m            strcpy(fc->name[14],"N_ncdm");[m
[32m+[m[32m            sprintf(fc->value[14],"%d",cosmology.N_ncdm);[m
[32m+[m[32m            //sprintf(fc->value[16],"%e",1.0);[m
[32m+[m[32m            //cosmology.N_ur = 1.0;[m
[32m+[m[32m            if (cosmology.Omega_nu>0.){[m
[32m+[m[32m              strcpy(fc->name[15],"Omega_ncdm");[m
[32m+[m[32m              if (cosmology.meff==0.0){sprintf(fc->value[15],"%e,%e,%e,%e",ncdm_mass_or_omega/3,ncdm_mass_or_omega/3,ncdm_mass_or_omega/3, 1.19522*pow(10,-05));}[m
[32m+[m[32m              else{sprintf(fc->value[15],"%e,%e,%e,%e",0.0,0.0,ncdm_mass_or_omega/93.14/cosmology.h0/cosmology.h0, cosmology.meff/94.1/cosmology.h0/cosmology.h0);}[m
[32m+[m[32m            }[m
[32m+[m[32m            else {sprintf(fc->value[15],"%e,%e,%e,%e",0.0,0.0,ncdm_mass_or_omega, cosmology.meff);}[m
[32m+[m[32m            //sprintf(fc->value[17],"%e,%e,%e,%e", Tncdm_standard, Tncdm_standard, Tncdm_standard, Tncdm_standard);[m
[32m+[m[32m            /*[m
[32m+[m[32m            if (cosmology.Omega_nu>0.){[m
[32m+[m[32m              if (cosmology.meff==0.0){sprintf(fc->value[15],"%e,%e,%e,%e",ncdm_mass_or_omega/3,ncdm_mass_or_omega/3,ncdm_mass_or_omega/3, 1.19522*pow(10,-05));}[m
[32m+[m[32m              else{sprintf(fc->value[15],"%e,%e,%e,%e",ncdm_mass_or_omega/3,ncdm_mass_or_omega/3,ncdm_mass_or_omega/3, cosmology.meff/94.1/cosmology.h0/cosmology.h0);}[m
[32m+[m[32m            }[m
[32m+[m[32m            else {sprintf(fc->value[15],"%e,%e,%e,%e",ncdm_mass_or_omega/3,ncdm_mass_or_omega/3,ncdm_mass_or_omega/3, cosmology.meff);}[m
[32m+[m[32m            */[m
[32m+[m[32m            //strcpy(fc->name[27],"ncdm_psd_parameters");[m
[32m+[m[32m            //sprintf(fc->value[27],"%e,%e,%e,%e",0.3 ,0.5, 0.05,0.0);[m
[32m+[m[32m            //strcpy(fc->name[28],"use_ncdm_psd_files");[m
[32m+[m[32m            //sprintf(fc->value[28],"%d,%d,%d,%d",0,0,0,0);[m
[32m+[m[32m            //strcpy(fc->name[26],"background_verbose");[m
[32m+[m[32m            //sprintf(fc->value[26],"%d",5);[m
[32m+[m[32m            //strcpy(fc->name[25],"thermodynamics_verbose");[m
[32m+[m[32m            //sprintf(fc->value[25],"%d",5);[m
[32m+[m[32m            //strcpy(fc->name[24],"ncdm_psd_filenames");[m
[32m+[m[32m            //sprintf(fc->value[24],"/home/paul/cosmolike_core/class/psd_FD_single.dat");[m
[32m+[m[41m            [m
[32m+[m[32m            break;[m
[32m+[m[32m          default:[m
[32m+[m[32m            printf("Unsupported neutrino parameterization. Exiting\n");[m
[32m+[m[32m            exit(1);[m
[32m+[m[32m          }[m
[32m+[m[32m            if(cosmology.N_eff<Neff_standard){[m
[32m+[m[32m              sprintf(fc->value[16],"%e",(Neff_standard - 1.0132*cosmology.N_ncdm));[m
[32m+[m[32m              sprintf(fc->value[17],"%f",Tncdm_standard*pow((cosmology.N_eff-(Neff_standard - 1.0132*cosmology.N_ncdm))/(1.0132*cosmology.N_ncdm), 0.25));[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m      }[m
[32m+[m[32m      //printf("%e %e\n", cosmology.N_ur, cosmology.Omega_nu);[m
[32m+[m[32m      //ultra-relativistic neutrinos have a very small energy density, should be taken into account when calculating Omega_cdm.[m[41m [m
[32m+[m[32m      //double Omega_ur = 0.0;[m
[32m+[m[32m      //If there is NCDM, then we should calculate the contribution of Omega_ur.[m[41m [m
[32m+[m[32m      //Otherwise, Omega_nu is the user's definition for Omega_ur and should be passed as such.[m
[32m+[m[32m      //if(cosmology.N_ncdm>0){[m
[32m+[m[32m        //double Omega_gammah2 = 2.47*pow(10,-5); //From planck, need reference[m
[32m+[m[32m        //Omega_ur = 7.0/8*cosmology.N_ur*pow(4.0/11, 4.0/3)*Omega_gammah2/cosmology.h0/cosmology.h0;[m
[32m+[m[32m      //}[m
[32m+[m[32m      strcpy(fc->name[7],"Omega_cdm");[m
[32m+[m[32m      sprintf(fc->value[7],"%e",cosmology.Omega_m-cosmology.omb-cosmology.Omega_nu);[m
[32m+[m
[32m+[m[32m    if(cosmology.xi_idr>0){[m
[32m+[m
[32m+[m[32m      //Energy density due to idr. assumes spin and color degeneracies are both 2, fermionic idr[m
[32m+[m[32m      double Omega_ur = 0.0;[m
[32m+[m
[32m+[m[32m      //double f_idm_dr=0.0001; //can alternatively define Omega_idm_dr. defines the fraction of total CDM that interacts with DR[m
[32m+[m[32m      double m_idm = 1.0e11;//1.0e11eV by default, models not very sensitive to variations (1706.06870)[m
[32m+[m[32m      //double xi_idr = 0.5;//can alternatively set N_idr. xi_idr is the ratio of T_DR to T_gamma.[m
[32m+[m[32m      double stat_f_idr = 0.875; //either 7/8 for fermionic(default) or 1 for bosonic. models not very sensitive to variations (1706.06870)[m
[32m+[m[32m      int idr_nature = 0; //free_streaming(0) or fluid(1)[m
[32m+[m[32m      int l_max_idr = 17; //17 by default, sets max multipole moment evaluates for DR (only relevant for free-stream case)[m[41m [m
[32m+[m[32m      double n_index_dark = 4;//4 by default, sets scattering rate as a power law of the temperature. Higher n -> more DAO[m
[32m+[m[32m      //double alpha_idm_dr = 1.5;//all 1.5 by default, DM-DR interaction angular coefficients for l=2 to l_max_idr, models not very sensitive to variations (1706.06870)[m
[32m+[m[32m      //double beta_idm_dr = 1.5;//all 1.5 by default, DR-DR interaction angular coefficients for l=2 to l_max_idr, models not very sensitive to variations (1706.06870)[m
[32m+[m[32m      double a_idm_dr = pow(10., 10);//0 by default, coupling strength between DM and DR[m
[32m+[m[32m      double b_idr =0;//pow(10,8);//0 by default, strength of DR self-interactions[m
[32m+[m
[32m+[m[32m      double Omega_idr = 2.0*2*stat_f_idr*1.235*pow(10.0, -5)*pow(cosmology.xi_idr, 4)/cosmology.h0/cosmology.h0;// page 6 of 1512.05344[m
[32m+[m[32m      sprintf(fc->value[7],"%e",cosmology.Omega_m-cosmology.Omega_nu-cosmology.omb-Omega_ur-Omega_idr);[m
[32m+[m[32m      strcpy(fc->name[17],"xi_idr");[m
[32m+[m[32m      sprintf(fc->value[17],"%e",cosmology.xi_idr);[m
[32m+[m
[32m+[m[32m      strcpy(fc->name[18],"Omega_idm_dr");[m
[32m+[m[32m      strcpy(fc->name[19],"stat_f_idr");[m
[32m+[m[32m      strcpy(fc->name[20],"idr_nature");[m
[32m+[m[32m      strcpy(fc->name[21],"l_max_idr");[m
[32m+[m[32m      strcpy(fc->name[22],"n_index_dark");[m
[32m+[m[32m      //strcpy(fc->name[23],"alpha_idm_dr");[m
[32m+[m[32m      //strcpy(fc->name[24],"beta_idm_dr");[m
[32m+[m[32m      strcpy(fc->name[25],"a_idm_dr");[m
[32m+[m[32m      strcpy(fc->name[26],"b_idr");[m
[32m+[m[32m      sprintf(fc->value[18],"%e",Omega_idr);[m
[32m+[m[32m      sprintf(fc->value[19],"%e",stat_f_idr);[m
[32m+[m[32m      sprintf(fc->value[20],"%d",idr_nature);[m
[32m+[m[32m      sprintf(fc->value[21],"%d",l_max_idr);[m
[32m+[m[32m      sprintf(fc->value[22],"%e",n_index_dark);[m
[32m+[m[32m      //sprintf(fc->value[23],"%e",alpha_idm_dr);[m
[32m+[m[32m      //sprintf(fc->value[24],"%e",beta_idm_dr);[m
[32m+[m[32m      sprintf(fc->value[25],"%e",a_idm_dr);[m
[32m+[m[32m      sprintf(fc->value[26],"%e",b_idr);[m
[32m+[m
     }[m
[31m-    strcpy(fc->name[16],"N_ur");[m
[31m-    sprintf(fc->value[16],"%e",2.0328);//0.00641);[m
[31m-  }[m
[32m+[m
   //normalization comes last, so that all other parameters are filled in for determining A_s if sigma_8 is specified[m
[32m+[m[32m    //printf("%e\n", cosmology.A_s);[m
   if (cosmology.A_s >0){[m
[31m-//  printf("passing A_s=%e directly\n",cosmology.A_s);[m
[32m+[m[32m    //printf("passing A_s=%e directly\n",cosmology.A_s);[m
    strcpy(fc->name[parser_length-1],"A_s");[m
    sprintf(fc->value[parser_length-1],"%e",cosmology.A_s);[m
   }[m
   else{[m
[31m-    double A_s = get_class_As(fc,parser_length-1,cosmology.sigma_8, &status);[m
     strcpy(fc->name[parser_length-1],"A_s");[m
[32m+[m[32m    double A_s = get_class_As(fc,parser_length-1,cosmology.sigma_8, &status);[m
[32m+[m
     sprintf(fc->value[parser_length-1],"%e",A_s);[m
     if (status == 0){[m
       A_s *=pow(cosmology.sigma_8/get_class_s8(fc,&status),2.0);[m
[31m-      strcpy(fc->name[parser_length-1],"A_s");[m
[31m-      sprintf(fc->value[parser_length-1],"%e",A_s);}[m
[32m+[m[32m    }[m
     cosmology.A_s = A_s;[m
[32m+[m[32m    sprintf(fc->value[parser_length-1],"%e",A_s);[m
     printf("determined A_s(sigma_8=%e) = %e\n", cosmology.sigma_8,A_s);[m
   }[m
[32m+[m
   strcpy(fc->name[1],"non linear");[m
   strcpy(fc->value[1],"Halofit"); //to use Halofit within CLASS[m
[32m+[m[32m  //fprint_parser(fc, parser_length);[m
   return status;[m
 }[m
 void fprint_parser(struct file_content * fc,int parser_length){[m
[36m@@ -672,10 +916,17 @@[m [mvoid fprint_parser(struct file_content * fc,int parser_length){[m
     fprintf(stderr, "%d %s %s\n",i, fc->name[i],fc->value[i]);[m
   }[m
 }[m
[31m-double p_class(double k_coverh0,double a, int NL, int *status){[m
[32m+[m[32mdouble p_class(double k_coverh0,double a, int NL, int CLUSTERING){[m
[32m+[m[32m  //CLASS version 2.9 supports copmuting the total matter power spectrum and the CDM+Baryon power spectrum.[m
[32m+[m[32m  //To retrieve the CDM+Baryon power spectrum, set CLUSTERING=1, 0 for total matter power spectrum.[m
[32m+[m[32m  //To retrieve a power spectrum with non-linear components, set NL=1[m
[32m+[m[32m  //NOTE: When no ncdm is used, the CDM+Baryon and total matter spectra will be equivalent.[m[41m [m
[32m+[m
   static cosmopara C;[m
   static double **table_P_L = 0;[m
   static double **table_P_NL = 0;[m
[32m+[m[32m  static double **table_P_L_C = 0;[m
[32m+[m[32m  static double **table_P_NL_C = 0;[m
   static double logkmin = 0., logkmax = 0., dk = 0., da = 0.;[m
   static int class_status = 0;[m
   double val,klog;[m
[36m@@ -684,6 +935,8 @@[m [mdouble p_class(double k_coverh0,double a, int NL, int *status){[m
     if (table_P_L ==0){[m
       table_P_L = create_double_matrix(0, Ntable.N_a-1, 0, Ntable.N_k_nlin-1);[m
       table_P_NL = create_double_matrix(0, Ntable.N_a-1, 0, Ntable.N_k_nlin-1);[m
[32m+[m[32m      table_P_L_C = create_double_matrix(0, Ntable.N_a-1, 0, Ntable.N_k_nlin-1);[m
[32m+[m[32m      table_P_NL_C = create_double_matrix(0, Ntable.N_a-1, 0, Ntable.N_k_nlin-1);[m
       da = (1. - limits.a_min)/(Ntable.N_a-1.);[m
       logkmin = log(limits.k_min_mpc*cosmology.coverH0);[m
       logkmax = log(limits.k_max_mpc_class*cosmology.coverH0);[m
[36m@@ -691,14 +944,15 @@[m [mdouble p_class(double k_coverh0,double a, int NL, int *status){[m
     }[m
     //allocate CLASS structures[m
     struct background ba;       // for cosmological background[m
[31m-    struct thermo th;           // for thermodynamics[m
[31m-    struct perturbs pt;         // for source functions[m
[31m-    struct transfers tr;        // for transfer functions[m
[32m+[m[32m    struct thermodynamics th;           // for thermodynamics[m
[32m+[m[32m    struct perturbations pt;         // for source functions[m
[32m+[m[32m    struct transfer tr;        // for transfer functions[m
     struct primordial pm;       // for primordial spectra[m
[31m-    struct spectra sp;          // for output spectra[m
[31m-    struct nonlinear nl;        // for non-linear spectra[m
[32m+[m[32m    struct harmonic hr;          // for output spectra[m
[32m+[m[32m    struct fourier fo;        // for non-linear spectra[m
     struct lensing le;[m
     struct output op;[m
[32m+[m[32m    struct distortions sd;[m
 [m
   	ErrorMsg errmsg; // for error messages[m
 [m
[36m@@ -706,7 +960,7 @@[m [mdouble p_class(double k_coverh0,double a, int NL, int *status){[m
   	int parser_length = 30;[m
   	if (parser_init(&fc,parser_length,"none",errmsg) == _FAILURE_){[m
      fprintf(stderr,"cosmo3D.c: CLASS parser init error:%s\n",errmsg);[m
[31m-     *status = 1;[m
[32m+[m[32m     class_status = 1;[m
      return 0.;[m
    }[m
    for (int i =0; i < parser_length; i++){[m
[36m@@ -714,49 +968,229 @@[m [mdouble p_class(double k_coverh0,double a, int NL, int *status){[m
      strcpy(fc.value[i]," ");[m
    }[m
 [m
[31m-   *status = fill_class_parameters(&fc,parser_length);[m
[31m-[m
[31m-   if(*status>0) return 1;[m
[31m-   *status = run_class(&fc,&ba,&th,&pt,&tr,&pm,&sp,&nl,&le);[m
[31m-   if(*status>0) {[m
[32m+[m[32m   class_status = fill_class_parameters(&fc,parser_length);[m
[32m+[m[32m   if(class_status>0) return 1;[m
[32m+[m[32m   class_status = run_class(&fc,&ba,&th,&pt,&tr,&pm,&hr,&fo,&le,&sd);[m
[32m+[m[32m     //fprint_parser(&fc, parser_length);[m
[32m+[m[32m   if(class_status>0) {[m
      fprint_parser(&fc,parser_length);[m
      parser_free(&fc);[m
      return 1;[m
    }[m
    parser_free(&fc);[m
[31m-   double aa,norm, k_class,Pk,ic;[m
[32m+[m[32m   double aa,norm, k_class,Pk,ic,Pk_c;[m
    int i,j,s;[m
    aa = limits.a_min;[m
    if (cosmology.A_s){[m
     norm = 3.*log(cosmology.h0/cosmology.coverH0);[m
[31m-    cosmology.sigma_8 = sp.sigma8;[m
[32m+[m[32m    cosmology.sigma_8 =  *fo.sigma8;[m
   }[m
   else{[m
[31m-    norm = log(pow(cosmology.sigma_8/sp.sigma8,2.)*pow(cosmology.h0/cosmology.coverH0,3.));[m
[31m-  }[m
[31m-    //printf("power spectrum scaling factor %e\n", pow(cosmology.sigma_8/sp.sigma8,2.));[m
[31m-  if (*status ==0){[m
[32m+[m[32m    norm = log(pow(cosmology.sigma_8/ *fo.sigma8,2.)*pow(cosmology.h0/cosmology.coverH0,3.));[m
[32m+[m[32m  }[m
[32m+[m[32m//    printf("power spectrum scaling factor %e\n", pow(cosmology.sigma_8/ *fo.sigma8,2.));[m
[32m+[m[32m  /*if (class_status ==0){[m
[32m+[m[32m  FILE *fp_lin;[m
[32m+[m[32m  FILE *fp_non;[m
[32m+[m[32m  FILE *fp_lin_c;[m
[32m+[m[32m  FILE *fp_non_c;[m
[32m+[m
[32m+[m[32m  char file_ending[100];[m
[32m+[m[32m  sprintf(file_ending, "_%d_Nncdm_%.5f_nonlinear_bias_const_As_efficient_ell_test_edits.txt", cosmology.N_ncdm, (cosmology.Omega_nu*cosmology.h0 * cosmology.h0));[m
[32m+[m[32m  if (cosmology.meff!=0.0){[m
[32m+[m[32m      sprintf(file_ending, "_%d_Nncdm_%.5f_nur_%.4f_meff_%.2f.txt", cosmology.N_ncdm, (cosmology.Omega_nu*cosmology.h0 * cosmology.h0), cosmology.N_ur,cosmology.meff);[m
[32m+[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m   char header[50];[m
[32m+[m[32m   char temp_name[200];[m
[32m+[m[32m   strcpy(temp_name,"");[m
[32m+[m[32m   strcpy(header,"./p_ks/P_lin");[m
[32m+[m[32m   strcat(temp_name, header);[m
[32m+[m[32m   strcat(temp_name, file_ending);[m
[32m+[m[32m   fp_lin = fopen(temp_name, "w+");[m
[32m+[m[32m   strcpy(temp_name,"");[m
[32m+[m[32m   strcpy(header,"./p_ks/P_non");[m
[32m+[m[32m   strcat(temp_name, header);[m
[32m+[m[32m   strcat(temp_name, file_ending);[m
[32m+[m[32m   fp_non = fopen(temp_name, "w+");[m
[32m+[m[32m   strcpy(temp_name,"");[m
[32m+[m[32m   strcpy(header,"./p_ks/P_lin_c");[m
[32m+[m[32m   strcat(temp_name, header);[m
[32m+[m[32m   strcat(temp_name, file_ending);[m
[32m+[m[32m   fp_lin_c = fopen(temp_name, "w+");[m
[32m+[m[32m   strcpy(temp_name,"");[m
[32m+[m[32m   strcpy(header,"./p_ks/P_non_c");[m
[32m+[m[32m   strcat(temp_name, header);[m
[32m+[m[32m   strcat(temp_name, file_ending);[m
[32m+[m[32m   fp_non_c = fopen(temp_name, "w+");[m
[32m+[m
[32m+[m[32m   printf("%s\n", file_ending);[m
[32m+[m
[32m+[m[32m   //printf("%d %e %e, %d %e %e\n", Ntable.N_a, da, aa, Ntable.N_k_nlin, dk, klog);[m
[32m+[m[32m   printf("norm %f\n", norm);*/[m
[32m+[m
     for (i=0; i<Ntable.N_a; i++, aa +=da) {[m
       klog = logkmin;[m
       for (j=0; j<Ntable.N_k_nlin; j++, klog += dk) {[m
         k_class =exp(klog)*cosmology.h0/cosmology.coverH0;[m
[31m-        s = spectra_pk_at_k_and_z(&ba, &pm, &sp,k_class,fmax(1./aa-1.,0.), &Pk,&ic);[m
[32m+[m
[32m+[m[32m        s=fourier_pk_at_k_and_z(&ba, &pm, &fo, pk_linear, k_class,fmax(1./aa-1.,0.), fo.index_pk_total, &Pk, &ic);[m
         table_P_L[i][j] = log(Pk) +norm;[m
[31m-        s = spectra_pk_nl_at_k_and_z(&ba, &pm, &sp,k_class,fmax(1./aa-1.,0.), &Pk);[m
[32m+[m[32m        s=fourier_pk_at_k_and_z(&ba, &pm, &fo, pk_nonlinear, k_class,fmax(1./aa-1.,0.), fo.index_pk_total,  &Pk, &ic);[m
         table_P_NL[i][j] = log(Pk) +norm;[m
[32m+[m[41m        [m
[32m+[m
[32m+[m[32m        s=fourier_pk_at_k_and_z(&ba, &pm, &fo, pk_linear, k_class,fmax(1./aa-1.,0.), fo.index_pk_cluster, &Pk, &ic);[m
[32m+[m[32m        table_P_L_C[i][j] = log(Pk) +norm;[m
[32m+[m
[32m+[m[32m        s=fourier_pk_at_k_and_z(&ba, &pm, &fo, pk_nonlinear, k_class,fmax(1./aa-1.,0.), fo.index_pk_cluster,  &Pk, &ic);[m
[32m+[m[32m        table_P_NL_C[i][j] = log(Pk) +norm;[m
[32m+[m
[32m+[m[32m        //printf("%d %d\n", i, j);[m
[32m+[m[32m        //printf("%f\n", table_P_NL_C[i][j]);[m
[32m+[m[32m        /*fprintf(fp_lin, "%.8lf %.8lf %.8lf\n", k_class, fmax(1./aa-1.,0.), table_P_L[i][j]);[m
[32m+[m[32m        fprintf(fp_non, "%.8lf %.8lf %.8lf\n", k_class, fmax(1./aa-1.,0.), table_P_NL[i][j]);[m
[32m+[m[32m        fprintf(fp_lin_c, "%.8lf %.8lf %.8lf\n", k_class, fmax(1./aa-1.,0.), table_P_L_C[i][j]);[m
[32m+[m[32m        fprintf(fp_non_c, "%.8lf %.8lf %.8lf\n", k_class, fmax(1./aa-1.,0.), table_P_NL_C[i][j]);*/[m
[32m+[m
[32m+[m
[32m+[m
       }[m
     }[m
[31m-    free_class_structs(&ba,&th,&pt,&tr,&pm,&sp,&nl,&le);[m
[31m-  }[m
[32m+[m[32m  //printf("%d %d %f %f\n", Ntable.N_a-1, Ntable.N_k_nlin-1, table_P_L_C[Ntable.N_a-1][Ntable.N_k_nlin-1], table_P_NL_C[0][0]);[m
[32m+[m
[32m+[m
[32m+[m[32m   /*fclose(fp_lin);[m
[32m+[m[32m   fclose(fp_non);[m
[32m+[m[32m   fclose(fp_lin_c);[m
[32m+[m[32m   fclose(fp_non_c);*/[m
[32m+[m[32m    free_class_structs(&ba,&th,&pt,&tr,&pm,&hr,&fo,&le,&sd);[m
[32m+[m[32m  //}[m
   update_cosmopara(&C);[m
 }[m
[32m+[m
 klog = log(k_coverh0);[m
 if (isnan(klog) || class_status) return 0.0;[m
[31m-if (NL==1) val = interpol2d_fitslope(table_P_NL, Ntable.N_a, limits.a_min, 1., da, fmin(a,.99), Ntable.N_k_nlin, logkmin, logkmax, dk, klog, cosmology.n_spec);[m
[31m-else val = interpol2d_fitslope(table_P_L, Ntable.N_a, limits.a_min, 1., da, fmin(a,.99), Ntable.N_k_nlin, logkmin, logkmax, dk, klog, cosmology.n_spec);[m
[32m+[m
[32m+[m[32mif(NL==1){[m
[32m+[m[32m  if (CLUSTERING==1) val = interpol2d_fitslope(table_P_NL_C, Ntable.N_a, limits.a_min, 1., da, fmin(a,.999999), Ntable.N_k_nlin, logkmin, logkmax, dk, klog, cosmology.n_spec);[m
[32m+[m[32m  else val = interpol2d_fitslope(table_P_NL, Ntable.N_a, limits.a_min, 1., da, fmin(a,.999999), Ntable.N_k_nlin, logkmin, logkmax, dk, klog, cosmology.n_spec);[m
[32m+[m[32m}[m
[32m+[m[32melse{[m
[32m+[m[32m  if (CLUSTERING==1) val = interpol2d_fitslope(table_P_L_C, Ntable.N_a, limits.a_min, 1., da, fmin(a,.999999), Ntable.N_k_nlin, logkmin, logkmax, dk, klog, cosmology.n_spec);[m
[32m+[m[32m  else val = interpol2d_fitslope(table_P_L, Ntable.N_a, limits.a_min, 1., da, fmin(a,.999999), Ntable.N_k_nlin, logkmin, logkmax, dk, klog, cosmology.n_spec);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
 if(isnan(val)) return 0.0;[m
 return exp(val);[m
 }[m
[32m+[m
[32m+[m[32mdouble p_lin_cluster(double k,double a)[m
[32m+[m[32m{[m
[32m+[m[32m  if (strcmp(pdeltaparams.runmode,"CLASS")==0 || strcmp(pdeltaparams.runmode,"class")==0){return p_class(k,a,0, 1);}[m
[32m+[m[32m  return p_lin(k,a);[m
[32m+[m[32m}[m
[32m+[m[32mdouble Pdelta_cluster(double k,double a)[m
[32m+[m[32m{[m
[32m+[m[32m  if (strcmp(pdeltaparams.runmode,"CLASS")==0 || strcmp(pdeltaparams.runmode,"class")==0){return p_class(k,a,1, 1);}[m
[32m+[m[32m  return Pdelta(k,a);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mdouble p_lin_cross_class(double k,double a)[m
[32m+[m[32m{[m
[32m+[m[32m  if (strcmp(pdeltaparams.runmode,"CLASS")==0 || strcmp(pdeltaparams.runmode,"class")==0){return sqrt(p_class(k,a,0, 1)*p_class(k,a,0,0));}[m
[32m+[m[32m  return 0.0;[m
[32m+[m[32m}[m
[32m+[m[32mdouble Pdelta_cross_class(double k,double a)[m
[32m+[m[32m{[m
[32m+[m[32m  if (strcmp(pdeltaparams.runmode,"CLASS")==0 || strcmp(pdeltaparams.runmode,"class")==0){return sqrt(p_class(k,a,1, 1)*p_class(k,a,1,0));}[m
[32m+[m[32m  return 0.0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mdouble growfac_cluster_from_class(double a){[m
[32m+[m[32m//  double k_small = limits.k_min_mpc*cosmology.coverH0*10.;[m
[32m+[m[32m  double k_small = 1.e-4*cosmology.coverH0;[m
[32m+[m[32m  return sqrt(Pdelta_cluster(k_small,a)/Pdelta_cluster(k_small,1.0));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mdouble growfac_cluster(double a)[m
[32m+[m[32m{[m
[32m+[m[32m  const double MINA=1.e-8;[m
[32m+[m[32m  static cosmopara C;[m
[32m+[m[32m  static double *ai_cluster;[m
[32m+[m[32m  static double *table_cluster;[m
[32m+[m[32m  double res;[m
[32m+[m
[32m+[m[32m  gsl_interp *intf=gsl_interp_alloc(gsl_interp_linear,Ntable.N_a);[m
[32m+[m[32m  gsl_interp_accel *acc=gsl_interp_accel_alloc();[m
[32m+[m
[32m+[m[32m  if (recompute_expansion(C))[m
[32m+[m[32m  {[m
[32m+[m
[32m+[m[32m    if(table_cluster!=0) free_double_vector(table_cluster,0, Ntable.N_a-1);[m
[32m+[m[32m    if(ai_cluster!=0) free_double_vector(ai_cluster,0, Ntable.N_a-1);[m
[32m+[m[32m    ai_cluster=create_double_vector(0, Ntable.N_a-1);[m
[32m+[m[32m    table_cluster=create_double_vector(0, Ntable.N_a-1);[m
[32m+[m
[32m+[m[32m    int i;[m
[32m+[m[32m    //if using CLASS, calculate growth factor from low-k ratio of power spectrum at different redshifts[m
[32m+[m[32m    if ((strcmp(pdeltaparams.runmode,"CLASS")==0 || strcmp(pdeltaparams.runmode,"class")==0) && cosmology.w0 == -1.0){[m
[32m+[m[32m      double da = (1. - limits.a_min)/(Ntable.N_a-1.);[m
[32m+[m
[32m+[m[32m      for (i=0;i< Ntable.N_a-1;i++) {[m
[32m+[m[32m        ai_cluster[i]=limits.a_min+i*da;[m
[32m+[m[32m        table_cluster[i] = growfac_cluster_from_class(ai_cluster[i]);[m
[32m+[m[32m        //printf("growfac_class(%.3f)=%.3f\n",ai[i],table[i]);[m
[32m+[m[32m      }[m
[32m+[m[32m      ai_cluster[Ntable.N_a-1] = 1.0;[m
[32m+[m[32m      table_cluster[Ntable.N_a-1] = 1.0;[m
[32m+[m[32m      update_cosmopara(&C);[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    //untested and not correct!!!!!![m
[32m+[m[32m    else{[m
[32m+[m[32m      const gsl_odeiv_step_type *T=gsl_odeiv_step_rkf45;[m
[32m+[m[32m      gsl_odeiv_step *s=gsl_odeiv_step_alloc(T,2);[m
[32m+[m[32m      gsl_odeiv_control *c=gsl_odeiv_control_y_new(1.e-6,0.0);[m
[32m+[m[32m      gsl_odeiv_evolve *e=gsl_odeiv_evolve_alloc(2);[m
[32m+[m
[32m+[m[32m      double t=MINA;            //start a[m
[32m+[m[32m      double t1=1.1;                //final a[m
[32m+[m[32m      double h=1.e-6;              //initial step size[m
[32m+[m[32m      double y[2]={MINA,MINA};   //initial conditions[m
[32m+[m[32m      double norm;[m
[32m+[m[32m      double par[0]={};[m
[32m+[m[32m      gsl_odeiv_system sys={func_for_growfac,NULL,2,&par};[m
[32m+[m
[32m+[m[32m      for (i=1;i<=Ntable.N_a;i++) {[m
[32m+[m[32m        ai_cluster[i-1]=i*t1/(1.*Ntable.N_a);[m
[32m+[m[32m        while(t<ai_cluster[i-1])[m
[32m+[m[32m          gsl_odeiv_evolve_apply(e,c,s,&sys,&t,ai_cluster[i-1],&h,y);[m
[32m+[m[32m        if (i==1) norm=y[0]/ai_cluster[i-1];[m
[32m+[m[32m        table_cluster[i-1]=y[0]/norm;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      gsl_odeiv_evolve_free(e);[m
[32m+[m[32m      gsl_odeiv_control_free(c);[m
[32m+[m[32m      gsl_odeiv_step_free(s);[m
[32m+[m[32m      update_cosmopara(&C);[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  gsl_interp_init(intf,ai_cluster,table_cluster,Ntable.N_a);[m
[32m+[m[32m  res=gsl_interp_eval(intf,ai_cluster,table_cluster,a,acc);[m
[32m+[m[32m  gsl_interp_accel_free(acc);[m
[32m+[m[32m  gsl_interp_free(intf);[m
[32m+[m[32m  return(res);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
 // linear power spectrum routine with k in units H_0/c; used in covariances.c for beat coupling and in halo.c[m
 double p_lin(double k,double a)[m
 {[m
[36m@@ -764,7 +1198,7 @@[m [mdouble p_lin(double k,double a)[m
   static double **table_P_Lz = 0;[m
   static double logkmin = 0., logkmax = 0., dk = 0., da = 0.;[m
   int status;[m
[31m-  if (strcmp(pdeltaparams.runmode,"CLASS")==0 || strcmp(pdeltaparams.runmode,"class")==0) return p_class(k,a,0, &status);[m
[32m+[m[32m  if (strcmp(pdeltaparams.runmode,"CLASS")==0 || strcmp(pdeltaparams.runmode,"class")==0) return p_class(k,a,0, 0);[m
 [m
   double amp,ampsqr,grow0,aa,klog,val;[m
 [m
[36m@@ -1449,7 +1883,7 @@[m [mdouble Pdelta(double k_NL,double a)[m
     case 1: pdelta=2.0*constants.pi_sqr*Delta_NL_emu(kintern,a)/k_NL/k_NL/k_NL; break;[m
     case 2: pdelta=2.0*constants.pi_sqr*Delta_NL_emu_only(kintern,a)/k_NL/k_NL/k_NL; break;[m
     case 3: pdelta=p_lin(k_NL,a); break;[m
[31m-    case 4: pdelta=p_class(k_NL,a,1, &status); break;[m
[32m+[m[32m    case 4: pdelta=p_class(k_NL,a,1, 0); break;[m
     case 5: k_nonlin=nonlinear_scale_computation(a);[m
     if (kintern<0.01) pdelta=2.0*constants.pi_sqr*Delta_NL_Halofit(kintern,a)/k_NL/k_NL/k_NL;[m
     else{[m
